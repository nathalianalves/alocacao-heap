alocaMem:
	pushq %rbp
	movq %rsp, %rbp
	subq $40, %rsp # aloca variaveis locais

	# INICIALIZAÇÃO DAS VARIAVEIS LOCAIS
	movq TOPO_INICIAL_HEAP, %rdx
	movq %rdx, -8(%rbp) # começa a percorrer no começo da heap
	movq TOPO_ATUAL_HEAP, %rax
	movq %rax, -16(%rbp) # -16(%rbp) = firstFit
	movq $0, -24(%rbp) # no inicio, ainda nao tem firstFit
	movq %rdi, -32(%rbp) # numBytes = parametro
	movq %rbx, -40(%rbp) # salva rbx

	# while (nodoAtual != TOPO_ATUAL_HEAP)
	whileAlocaMem:
	movq TOPO_ATUAL_HEAP, %rax
	cmpq %rax, -8(%rbp)
	je fimWhileAlocaMem

	# se firstFit ja foi encontrado, sai do while
	cmpq $1, -24(%rbp)
	je fimWhileAlocaMem
	
	# if (nodoAtual é livre) 
	movq -8(%rbp), %rbx
	movq (%rbx), %rax
	cmpq $1, %rax
	je proximoBlocoAlocaMem

	# if (nodoAtual é livre) e (tam(nodoAtual) >= numBytes)
	movq -8(%rbp), %rbx
	addq $8, %rbx # rbx := endereço do tamanho de notoAtual
	movq (%rbx), %rax # rax := tamanho de nodoAtual
	
	movq -24(%rbp), %rbx
	cmpq $1, %rbx
	je whileAlocaMem
	

	# se nenhum firstFit foi encontrado até então, altera firstFit para o atual e achouBestFit = 1
	movq -8(%rbp), %rax
	movq %rax, -16(%rbp)
	movq $1, -24(%rbp)
	jmp proximoBlocoAlocaMem

	proximoBlocoAlocaMem:
	movq -8(%rbp), %rax
	addq $8, %rax
	movq (%rax), %rdi # rdi := tamanho do nodo atual
	addq $16, -8(%rbp) # "pula" as informações gerenciais do bloco atual
	addq %rdi, -8(%rbp) # "pula" os bytes usaveis do bloco atual
	jmp whileAlocaMem # volta para o começo do while

	fimWhileAlocaMem:
	# se bestFit é o topo da heap atual, segue o mesmo fluxo. Se não é, lida com o bloco que vai ser separado
	movq TOPO_ATUAL_HEAP, %rdi
	cmpq -16(%rbp), %rdi
	jne separaBestFitAlocaMem

	# CASO 1: bestFit é o topo atual da heap
	movq TOPO_ATUAL_HEAP, %r14 # r14 salva topo da heap (que será atualizado)
	addq $16, TOPO_ATUAL_HEAP # abre espaço para as informações gerenciais
	movq -32(%rbp), %rbx # rbx := espaço solicitado
	addq %rbx, TOPO_ATUAL_HEAP # abre espaço solicitado

	# verifica se BRK >= TOPO_ATUAL_HEAP. Se não for, brk precisa ser alterado
	movq TOPO_ATUAL_HEAP, %rax
	movq BRK, %rdi
	cmpq %rax, %rdi
	jge atualizaTopoHeap

	# altera o brk para o primeiro multiplo de 4096 maior que TOPO_ATUAL_HEAP
	movq TOPO_ATUAL_HEAP, %rax
	# addq -32(%rbp), %rax # rax := topoHeap + numBytes
	movq BRK, %rdi
	WhileAcharMultiplo:
	addq $4096, %rdi
	cmpq %rax, %rdi
	jl WhileAcharMultiplo
	movq $12, %rax
	syscall # altera o brk para o valor de %rdi
	movq %rdi, BRK

	atualizaTopoHeap:
	addq $8, %r14 # r14 := endereço que armazena o tamanho do bloco novo
	movq -32(%rbp), %rbx 
	movq %rbx, (%r14) # tamanho do bloco novo := numBytes
	jmp fimAlocaMem

	# CASO 2: bestFit é um bloco que já existe
	separaBestFitAlocaMem:
	movq -16(%rbp), %rax # rax := bestFit
	movq %rax, %rbx
	addq $8, %rbx # rbx := endereço do tamanho de bestFit
	movq (%rbx), %r10 # r10 := tamanho de bestFit
	movq %r10, %r11 
	subq -32(%rbp), %r11 # r11 := diferença entre tamanho de bestFit e tamanho pedido
	cmpq $16, %r11
	jle fimAlocaMem # se, usando os bytes pedidos, não sobrar espaço para informações gerenciais + bytes usaveis, nao separa o bloco

	# Configura o bloco novo (o segundo)
	addq $8, %rbx # rbx := fim dos bytes de informações gerenciais em bestFit
	addq -32(%rbp), %rbx # rbx := começo do bloco a ser criado
	movq $0, (%rbx) # bloco novo é livre
	subq $16, %r11 # r11 := tamanho do segundo bloco (-16 das informações gerenciais)
	addq $8, %rbx # rbx := endereço da 2a informação gerencial do bloco novo
	movq %r11, (%rbx) # configura tamanho do bloco novo

	# Configura o primeiro bloco (com os bytes pedidos)
	movq %rax, %rbx # rbx := bloco pedido
	addq $8, %rbx # rbx := 2a informação gerencial do bloco pedido
	movq -32(%rbp), %r12 # r12 := numBytes
	movq %r12, (%rbx) # tamanho do bloco pedido = numBytes

	fimAlocaMem:
	movq -16(%rbp), %rax # rax = bestFit (retorno)
	movq $1, (%rax) # 1a informação gerencial do retorno = 1 (bloco usado)
	addq $16, %rax # rax = começo dos bytes usaveis do bloco pedido
	movq -40(%rbp), %rbx # restaura rbx
	addq $40, %rsp # desaloca variaveis locais
	popq %rbp
	ret
